#!/usr/bin/env bash
set -euo pipefail

resolve_path() {
  python3 - "$1" <<'PY'
import os, sys
print(os.path.realpath(sys.argv[1]))
PY
}

SCRIPT_PATH="$(resolve_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

DEFAULT_BASE_IMAGE="debian:bookworm-slim"
VERBOSE="${AGENTBOX_VERBOSE:-0}"
DEFAULT_ALLOW_HOSTS=(
  "api.openai.com"
  "platform.openai.com"
  "chatgpt.com"
  "chat.openai.com"
  "auth.openai.com"
  "api.anthropic.com"
)
CONFIG_PROJECT="${PWD}/.agentbox"
CONFIG_HOME="${HOME}/.agentbox"
CONFIG_PATHS_JOINED="$(printf '%s:' "${CONFIG_PROJECT}" "${CONFIG_HOME}")"

TARGET_AGENT="${AGENTBOX_AGENT:-}"
BASE_IMAGE="${DEFAULT_BASE_IMAGE}"
BUILD_ONLY=0
PROMPT_VALUE=""
FULL_NETWORK=0
TOOLKITS=()
CUSTOM_CMD=()
HOST_CODEX_AUTH="${AGENTBOX_CODEX_AUTH:-${HOME}/.codex}"
HOST_CLAUDE_AUTH="${AGENTBOX_CLAUDE_AUTH:-${HOME}/.claude}"

if [[ -n "${DOCKER_CONFIG:-}" && ! -d "${DOCKER_CONFIG}" ]]; then
  fatal "DOCKER_CONFIG points to '${DOCKER_CONFIG}' but it does not exist; create it or unset DOCKER_CONFIG."
fi

usage() {
  cat <<'USAGE'
Usage: bin/agentbox-run [--base <image>] [--build-only] <agent> [-- <command>]

Minimal launcher: builds the image (if needed) and runs the agent with a network allowlist (OpenAI/Anthropic by default).

Options:
  --base <image>     Override base image (default: debian:bookworm-slim)
  --build-only       Build the image and exit
  --prompt <text>    Run a one-off Codex exec with the given prompt (codex only)
  --full-network     Disable firewall allowlist (bridge networking)
  -h, --help         Show this help
USAGE
}

fatal() { echo "agentbox-run: $*" >&2; exit 1; }

while [[ $# -gt 0 ]]; do
  case "$1" in
    --base)
      [[ $# -ge 2 ]] || fatal "--base requires a value"
      BASE_IMAGE="$2"; shift 2;;
    --build-only)
      BUILD_ONLY=1; shift;;
    --prompt)
      [[ $# -ge 2 ]] || fatal "--prompt requires a value"
      PROMPT_VALUE="$2"; shift 2;;
    --full-network)
      FULL_NETWORK=1; shift;;
    -h|--help)
      usage; exit 0;;
    --)
      shift; CUSTOM_CMD=("$@"); break;;
    -*)
      fatal "Unknown option '$1'";;
    *)
      if [[ -z "${TARGET_AGENT}" ]]; then
        TARGET_AGENT="$1"; shift
        CUSTOM_CMD=("$@"); break
      else
        CUSTOM_CMD+=("$1"); shift
      fi
      ;;
  esac
done

if [[ -z "${TARGET_AGENT}" ]]; then
  fatal "Missing agent argument"
fi

TTY_OPT=""
if [[ -t 0 && -t 1 ]]; then
  TTY_OPT="-t"
fi

RUN_CMD=()
if [[ -n "${PROMPT_VALUE}" && "${TARGET_AGENT}" == "codex" ]]; then
  RUN_CMD=("codex" "exec" "${PROMPT_VALUE}" "--json" "--skip-git-repo-check" "--dangerously-bypass-approvals-and-sandbox")
elif [[ ${#CUSTOM_CMD[@]} -gt 0 ]]; then
  RUN_CMD=("${CUSTOM_CMD[@]}")
else
  if [[ "${TARGET_AGENT}" == "codex" ]]; then
    RUN_CMD=("codex" "--dangerously-bypass-approvals-and-sandbox")
    if [[ -z "${TTY_OPT}" ]]; then
      RUN_CMD=("/bin/bash")
    fi
  elif [[ "${TARGET_AGENT}" == "claude" ]]; then
    RUN_CMD=("claude" "--dangerously-skip-permissions")
  else
    RUN_CMD=("/bin/bash")
  fi
fi

compute_toolkits() {
  if ! command -v python3 >/dev/null 2>&1; then
    fatal "python3 is required for parsing .agentbox"
  fi

  local py_tmp
  py_tmp="$(mktemp)"
  cat >"${py_tmp}" <<'PY'
import os, re

config_paths = [p for p in os.environ.get("CONFIG_PATHS", "").split(":") if p]
selected = []

def process_raw(raw: str):
    toml_mod = None
    try:
        import tomllib as toml_mod  # type: ignore
    except ModuleNotFoundError:
        try:
            import tomli as toml_mod  # type: ignore
        except ModuleNotFoundError:
            toml_mod = None

    data = None
    if toml_mod:
        try:
            data = toml_mod.loads(raw)
        except Exception:
            data = None

    if data is not None:
        for name in data.get("toolkits", {}).get("selected", []):
            if isinstance(name, str):
                selected.append(name.strip())
    else:
        toolkits_pat = re.compile(r'\[toolkits\].*?selected\s*=\s*\[(.*?)\]', re.DOTALL)
        m = toolkits_pat.search(raw)
        if m:
            items = re.findall(r'["\']([^"\']+)["\']', m.group(1))
            for name in items:
                selected.append(name.strip())

for path in config_paths:
    if not os.path.isfile(path):
        continue
    with open(path, "r", encoding="utf-8") as f:
        process_raw(f.read())

names = sorted({n for n in selected if n})
print(" ".join(names))
PY

  local tk_joined
  tk_joined="$(CONFIG_PATHS="${CONFIG_PATHS_JOINED}" python3 "${py_tmp}")"
  local status=$?
  rm -f "${py_tmp}"
  if [[ ${status} -ne 0 ]]; then
    fatal "failed to parse toolkits from .agentbox"
  fi

  TOOLKITS=()
  IFS=' ' read -r -a TOOLKITS <<<"${tk_joined}"
}

compute_allow_hosts() {
  if ! command -v python3 >/dev/null 2>&1; then
    fatal "python3 is required for parsing .agentbox"
  fi

  local defaults_joined
  defaults_joined="$(printf '%s\n' "${DEFAULT_ALLOW_HOSTS[@]}" | paste -sd' ' -)"

  local py_tmp
  py_tmp="$(mktemp)"
  cat >"${py_tmp}" <<'PY'
import os, re

defaults = [h for h in os.environ.get("DEFAULT_ALLOW_HOSTS_STR", "").split() if h]
config_paths = [p for p in os.environ.get("CONFIG_PATHS", "").split(":") if p]

allow = set(defaults)
block = set()

def process_raw(raw: str):
    toml_mod = None
    try:
        import tomllib as toml_mod  # type: ignore
    except ModuleNotFoundError:
        try:
            import tomli as toml_mod  # type: ignore
        except ModuleNotFoundError:
            toml_mod = None

    data = None
    if toml_mod:
        try:
            data = toml_mod.loads(raw)
        except Exception:
            data = None

    if data is not None:
        for entry in data.get("network", {}).get("allow", []):
            host = entry.get("host")
            if host:
                allow.add(host.strip())
        for entry in data.get("network", {}).get("block", []):
            host = entry.get("host")
            if host:
                block.add(host.strip())
    else:
        allow_pat = re.compile(r'\[\s*\[\s*network\.allow\s*\]\s*\].*?host\s*=\s*["\']([^"\']+)["\']', re.DOTALL)
        block_pat = re.compile(r'\[\s*\[\s*network\.block\s*\]\s*\].*?host\s*=\s*["\']([^"\']+)["\']', re.DOTALL)
        for host in allow_pat.findall(raw):
            allow.add(host.strip())
        for host in block_pat.findall(raw):
            block.add(host.strip())

for path in config_paths:
    if not os.path.isfile(path):
        continue
    with open(path, "r", encoding="utf-8") as f:
        process_raw(f.read())

effective = sorted(h for h in allow if h and h not in block)
print(" ".join(effective))
PY

  local allow_joined
  allow_joined="$(
    DEFAULT_ALLOW_HOSTS_STR="${defaults_joined}" CONFIG_PATHS="${CONFIG_PATHS_JOINED}" python3 "${py_tmp}"
  )"
  local status=$?
  rm -f "${py_tmp}"
  if [[ ${status} -ne 0 ]]; then
    fatal "failed to parse network config"
  fi

  IFS=' ' read -r -a ALLOW_HOSTS <<<"${allow_joined}"
}

compute_toolkits
compute_allow_hosts

TOOLKITS_CSV="$(IFS=,; echo "${TOOLKITS[*]-}")"
TOOLKIT_TAG="none"
if [[ ${#TOOLKITS[@]-0} -gt 0 ]]; then
  TOOLKIT_TAG="$(printf "%s," "${TOOLKITS[@]}" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9,' '_' | sed 's/,$//')"
fi

TAG="agentbox/${TARGET_AGENT}:$(echo "${BASE_IMAGE}" | tr '/:' '_')_${TOOLKIT_TAG}"

if [[ "${VERBOSE}" == "1" ]]; then
  echo "-> Building image ${TAG} (base: ${BASE_IMAGE}, toolkits: ${TOOLKITS_CSV:-none})" >&2
  docker build \
    --file "${REPO_ROOT}/docker/Dockerfile" \
    --build-arg "BASE_IMAGE=${BASE_IMAGE}" \
    --build-arg "TOOLKITS=${TOOLKITS_CSV}" \
    --tag "${TAG}" \
    "${REPO_ROOT}"
else
  docker build \
    --quiet \
    --file "${REPO_ROOT}/docker/Dockerfile" \
    --build-arg "BASE_IMAGE=${BASE_IMAGE}" \
    --build-arg "TOOLKITS=${TOOLKITS_CSV}" \
    --tag "${TAG}" \
    "${REPO_ROOT}" >/dev/null
fi

if [[ "${BUILD_ONLY}" -eq 1 ]]; then
  echo "Build complete for ${TARGET_AGENT}"
  exit 0
fi

[[ "${VERBOSE}" == "1" ]] && echo "-> Launching sandbox for ${TARGET_AGENT}" >&2
MOUNTS=("-v" "${PWD}":/workspace)
if [[ "${TARGET_AGENT}" == "codex" && -d "${HOST_CODEX_AUTH}" ]]; then
  MOUNTS+=("-v" "${HOST_CODEX_AUTH}:/home/agent/.codex")
fi
if [[ "${TARGET_AGENT}" == "claude" && -d "${HOST_CLAUDE_AUTH}" ]]; then
  MOUNTS+=("-v" "${HOST_CLAUDE_AUTH}:/home/agent/.claude")
fi

NETWORK_ARGS=()
FIREWALL_CID=""
ALLOW_HOSTS_ENV="${ALLOW_HOSTS[*]}"
ALLOWLIST_DESC="${ALLOW_HOSTS_ENV}"
[[ -z "${ALLOWLIST_DESC}" ]] && ALLOWLIST_DESC="none"

cleanup() {
  if [[ -n "${FIREWALL_CID}" ]]; then
    docker rm -f "${FIREWALL_CID}" >/dev/null 2>&1 || true
  fi
}
trap cleanup EXIT

if [[ "${FULL_NETWORK}" -eq 1 ]]; then
  NETWORK_ARGS=(--network bridge)
else
  FIREWALL_NAME="agentbox-firewall-${TARGET_AGENT}-$$"
  [[ "${VERBOSE}" == "1" ]] && echo "-> Starting firewall container (${ALLOWLIST_DESC})" >&2
  FIREWALL_CID="$(docker run \
    --rm \
    -d \
    --name "${FIREWALL_NAME}" \
    --network bridge \
    --cap-drop ALL \
    --cap-add NET_ADMIN \
    --security-opt no-new-privileges \
    --user root \
    --entrypoint /usr/local/bin/agent-firewall \
    -e "ALLOW_HOSTS=${ALLOW_HOSTS_ENV}" \
    -e "VERBOSE=${VERBOSE}" \
    "${TAG}")"
  NETWORK_ARGS=(--network "container:${FIREWALL_CID}")
fi

docker run \
  --rm \
  -i \
  ${TTY_OPT:+${TTY_OPT}} \
  --name "agentbox-${TARGET_AGENT}-$$" \
  "${NETWORK_ARGS[@]}" \
  --cap-drop ALL \
  --pids-limit 512 \
  --security-opt no-new-privileges \
  --workdir /workspace \
  "${MOUNTS[@]}" \
  "${TAG}" \
  "${RUN_CMD[@]}"

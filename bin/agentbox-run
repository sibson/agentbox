#!/usr/bin/env bash
set -euo pipefail

resolve_path() {
  python3 - "$1" <<'PY'
import os, sys
print(os.path.realpath(sys.argv[1]))
PY
}

SCRIPT_PATH="$(resolve_path "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(cd "$(dirname "${SCRIPT_PATH}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"

DEFAULT_BASE_IMAGE="debian:bookworm-slim"
VERBOSE="${AGENTBOX_VERBOSE:-0}"
DEFAULT_ALLOW_HOSTS=(
  "api.openai.com"
  "platform.openai.com"
  "chatgpt.com"
  "chat.openai.com"
  "auth.openai.com"
  "api.anthropic.com"
)
CONFIG_PROJECT_DIR="${PWD}/.agentbox"
CONFIG_HOME_DIR="${HOME}/.agentbox"
CONFIG_PROJECT="${CONFIG_PROJECT_DIR}/config.toml"
CONFIG_HOME="${CONFIG_HOME_DIR}/config.toml"
CONFIG_PATHS_JOINED="$(printf '%s:' "${CONFIG_PROJECT}" "${CONFIG_HOME}")"
LAST_AGENT_FILE_DEFAULT="${CONFIG_HOME_DIR}/last_agent"
LAST_AGENT_FILE="${AGENTBOX_LAST_AGENT_FILE:-${LAST_AGENT_FILE_DEFAULT}}"

TARGET_AGENT="${AGENTBOX_AGENT:-}"
BASE_IMAGE="${DEFAULT_BASE_IMAGE}"
BUILD_ONLY=0
PROMPT_VALUE=""
FULL_NETWORK=0
TOOLKITS=()
CUSTOM_CMD=()
HOST_CODEX_AUTH="${AGENTBOX_CODEX_AUTH:-${HOME}/.codex}"
HOST_CLAUDE_AUTH="${AGENTBOX_CLAUDE_AUTH:-${HOME}/.claude}"

if [[ -n "${DOCKER_CONFIG:-}" && ! -d "${DOCKER_CONFIG}" ]]; then
  fatal "DOCKER_CONFIG points to '${DOCKER_CONFIG}' but it does not exist; create it or unset DOCKER_CONFIG."
fi

usage() {
  cat <<'USAGE'
Usage: bin/agentbox-run [--base <image>] [--build-only] <agent> [-- <command>]

Minimal launcher: builds the image (if needed) and runs the agent with a network allowlist (OpenAI/Anthropic by default).

Options:
  --base <image>     Override base image (default: debian:bookworm-slim)
  --build-only       Build the image and exit
  --prompt <text>    Run a one-off Codex exec with the given prompt (codex only)
  --full-network     Disable firewall allowlist (bridge networking)
  -h, --help         Show this help
USAGE
}

fatal() { echo "agentbox-run: $*" >&2; exit 1; }

compute_default_agent() {
  if ! command -v python3 >/dev/null 2>&1; then
    fatal "python3 is required for parsing .agentbox"
  fi

  local py_tmp
  py_tmp="$(mktemp)"
  cat >"${py_tmp}" <<'PY'
import os, re

def extract_default(raw_text):
    toml_mod = None
    try:
        import tomllib as toml_mod  # type: ignore[attr-defined]
    except ModuleNotFoundError:
        try:
            import tomli as toml_mod  # type: ignore[assignment]
        except ModuleNotFoundError:
            toml_mod = None

    if toml_mod:
        try:
            data = toml_mod.loads(raw_text)
        except Exception:
            data = None
        if data is not None:
            value = data.get("agent", {}).get("default")
            if isinstance(value, str):
                value = value.strip()
                if value:
                    return value

    m = re.search(r'\[agent\].*?default\s*=\s*["\']([^"\']+)["\']', raw_text, re.DOTALL)
    if m:
        value = m.group(1).strip()
        if value:
            return value
    return ""

config_paths = [p for p in os.environ.get("CONFIG_PATHS", "").split(":") if p]
for path in config_paths:
    if not os.path.isfile(path):
        continue
    with open(path, "r", encoding="utf-8") as f:
        default_val = extract_default(f.read())
        if default_val:
            print(default_val)
            break
PY

  local default_agent
  default_agent="$(CONFIG_PATHS="${CONFIG_PATHS_JOINED}" python3 "${py_tmp}")"
  local status=$?
  rm -f "${py_tmp}"
  if [[ ${status} -ne 0 ]]; then
    fatal "failed to parse default agent from .agentbox"
  fi

  echo "${default_agent}"
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --base)
      [[ $# -ge 2 ]] || fatal "--base requires a value"
      BASE_IMAGE="$2"; shift 2;;
    --build-only)
      BUILD_ONLY=1; shift;;
    --prompt)
      [[ $# -ge 2 ]] || fatal "--prompt requires a value"
      PROMPT_VALUE="$2"; shift 2;;
    --full-network)
      FULL_NETWORK=1; shift;;
    -h|--help)
      usage; exit 0;;
    --)
      shift; CUSTOM_CMD=("$@"); break;;
    -*)
      fatal "Unknown option '$1'";;
    *)
      if [[ -z "${TARGET_AGENT}" ]]; then
        TARGET_AGENT="$1"; shift
        CUSTOM_CMD=("$@"); break
      else
        CUSTOM_CMD+=("$1"); shift
      fi
      ;;
  esac
done

DEFAULT_AGENT=""
DEFAULT_AGENT="$(compute_default_agent)"

if [[ -z "${TARGET_AGENT}" && -n "${DEFAULT_AGENT}" ]]; then
  if [[ "${DEFAULT_AGENT}" == "last_used" ]]; then
    if [[ -f "${LAST_AGENT_FILE}" ]]; then
      TARGET_AGENT="$(tr -d '[:space:]' < "${LAST_AGENT_FILE}")"
    fi
  else
    TARGET_AGENT="${DEFAULT_AGENT}"
  fi
fi

if [[ -z "${TARGET_AGENT}" ]]; then
  fatal "Missing agent argument (pass 'codex' or 'claude', or set [agent].default in .agentbox)"
fi

TTY_OPT=""
if [[ -t 0 && -t 1 ]]; then
  TTY_OPT="-t"
fi

RUN_CMD=()
if [[ -n "${PROMPT_VALUE}" && "${TARGET_AGENT}" == "codex" ]]; then
  RUN_CMD=("codex" "exec" "${PROMPT_VALUE}" "--json" "--skip-git-repo-check" "--dangerously-bypass-approvals-and-sandbox")
elif [[ ${#CUSTOM_CMD[@]} -gt 0 ]]; then
  RUN_CMD=("${CUSTOM_CMD[@]}")
else
  if [[ "${TARGET_AGENT}" == "codex" ]]; then
    RUN_CMD=("codex" "--dangerously-bypass-approvals-and-sandbox")
    if [[ -z "${TTY_OPT}" ]]; then
      RUN_CMD=("/bin/bash")
    fi
  elif [[ "${TARGET_AGENT}" == "claude" ]]; then
    RUN_CMD=("claude" "--dangerously-skip-permissions")
  else
    RUN_CMD=("/bin/bash")
  fi
fi

compute_toolkits() {
  if ! command -v python3 >/dev/null 2>&1; then
    fatal "python3 is required for parsing .agentbox"
  fi

  local py_tmp
  py_tmp="$(mktemp)"
cat >"${py_tmp}" <<'PY'
import os, re

config_paths = [p for p in os.environ.get("CONFIG_PATHS", "").split(":") if p]
selected = []

def process_raw(raw: str):
    toml_mod = None
    try:
        import tomllib as toml_mod  # type: ignore
    except ModuleNotFoundError:
        try:
            import tomli as toml_mod  # type: ignore
        except ModuleNotFoundError:
            toml_mod = None

    data = None
    if toml_mod:
        try:
            data = toml_mod.loads(raw)
        except Exception:
            data = None

    if data is not None:
        for name in data.get("toolkits", {}).get("selected", []):
            if isinstance(name, str):
                selected.append(name.strip())
    else:
        toolkits_pat = re.compile(r'\[toolkits\].*?selected\s*=\s*\[(.*?)\]', re.DOTALL)
        m = toolkits_pat.search(raw)
        if m:
            items = re.findall(r'["\']([^"\']+)["\']', m.group(1))
            for name in items:
                selected.append(name.strip())

for path in config_paths:
    if not os.path.isfile(path):
        continue
    with open(path, "r", encoding="utf-8") as f:
        process_raw(f.read())

names = sorted({n for n in selected if n})
print(" ".join(names))
PY

  local tk_joined
  tk_joined="$(CONFIG_PATHS="${CONFIG_PATHS_JOINED}" python3 "${py_tmp}")"
  local status=$?
  rm -f "${py_tmp}"
  if [[ ${status} -ne 0 ]]; then
    fatal "failed to parse toolkits from .agentbox"
  fi

  TOOLKITS=()
  IFS=' ' read -r -a TOOLKITS <<<"${tk_joined}"
}

compute_allow_hosts() {
  if ! command -v python3 >/dev/null 2>&1; then
    fatal "python3 is required for parsing .agentbox"
  fi

  local defaults_joined
  defaults_joined="$(printf '%s\n' "${DEFAULT_ALLOW_HOSTS[@]}" | paste -sd' ' -)"

  local py_tmp
  py_tmp="$(mktemp)"
  cat >"${py_tmp}" <<'PY'
import os, re
from fnmatch import fnmatch as fnmatch_match

def parse_hosts(value):
    hosts = []
    if isinstance(value, list):
        for h in value:
            if isinstance(h, str):
                h = h.strip()
                if h:
                    hosts.append(h)
    elif isinstance(value, str):
        for h in value.split(","):
            h = h.strip()
            if h:
                hosts.append(h)
    return hosts

def read_hosts_file(path, base_dir):
    if not path:
        return []
    resolved = path
    if not os.path.isabs(resolved):
        resolved = os.path.join(base_dir, resolved)
    if not os.path.isfile(resolved):
        return []
    hosts = []
    with open(resolved, "r", encoding="utf-8") as f:
        for line in f:
            line = line.split("#", 1)[0].strip()
            if line:
                hosts.append(line)
    return hosts

defaults = [h for h in os.environ.get("DEFAULT_ALLOW_HOSTS_STR", "").split() if h]
config_paths = [p for p in os.environ.get("CONFIG_PATHS", "").split(":") if p]

allow = set(defaults)
block = set()

def process_path(path: str):
    if not os.path.isfile(path):
        return
    base_dir = os.path.dirname(path) or "."
    raw_text = ""
    with open(path, "r", encoding="utf-8") as f:
        raw_text = f.read()

    toml_mod = None
    try:
        import tomllib as toml_mod  # type: ignore[attr-defined]
    except ModuleNotFoundError:
        try:
            import tomli as toml_mod  # type: ignore[assignment]
        except ModuleNotFoundError:
            toml_mod = None

    data = None
    if toml_mod:
        try:
            data = toml_mod.loads(raw_text)
        except Exception:
            data = None

    allow_hosts = []
    block_hosts = []
    allow_file = None

    if data is not None:
        network = data.get("network", {})
        allow_hosts = parse_hosts(network.get("allow_hosts", []))
        block_hosts = parse_hosts(network.get("block_hosts", []))
        allow_file = network.get("allow_file")
    else:
        allow_match = re.search(r'allow_hosts\s*=\s*\[(.*?)\]', raw_text, re.DOTALL)
        block_match = re.search(r'block_hosts\s*=\s*\[(.*?)\]', raw_text, re.DOTALL)
        file_match = re.search(r'allow_file\s*=\s*["\']([^"\']+)["\']', raw_text)
        if allow_match:
            allow_hosts = [h.strip() for h in re.findall(r'["\']([^"\']+)["\']', allow_match.group(1))]
        if block_match:
            block_hosts = [h.strip() for h in re.findall(r'["\']([^"\']+)["\']', block_match.group(1))]
        if file_match:
            allow_file = file_match.group(1).strip()

    for host in allow_hosts:
        if host:
            allow.add(host)
    for host in block_hosts:
        if host:
            block.add(host)
    for host in read_hosts_file(allow_file, base_dir):
        if host:
            allow.add(host)

for path in config_paths:
    process_path(path)

def is_blocked(host: str, patterns) -> bool:
    if host in block:
        return True
    for pat in patterns:
        if not pat:
            continue
        if pat == host or fnmatch_match(host, pat):
            return True
    return False

block_patterns = sorted(block)
effective = sorted(h for h in allow if h and not is_blocked(h, block_patterns))
print(" ".join(effective))
PY

  local allow_joined
  allow_joined="$(
    DEFAULT_ALLOW_HOSTS_STR="${defaults_joined}" CONFIG_PATHS="${CONFIG_PATHS_JOINED}" python3 "${py_tmp}"
  )"
  local status=$?
  rm -f "${py_tmp}"
  if [[ ${status} -ne 0 ]]; then
    fatal "failed to parse network config"
  fi

  IFS=' ' read -r -a ALLOW_HOSTS <<<"${allow_joined}"
}

record_last_agent() {
  if [[ "${AGENTBOX_ONLY_PRINT_ALLOWLIST:-0}" == "1" ]]; then
    return
  fi
  [[ -z "${LAST_AGENT_FILE}" ]] && return
  local dir
  dir="$(dirname "${LAST_AGENT_FILE}")"
  mkdir -p "${dir}" >/dev/null 2>&1 || return
  printf '%s\n' "${TARGET_AGENT}" > "${LAST_AGENT_FILE}" 2>/dev/null || true
}

compute_toolkits
compute_allow_hosts
record_last_agent

if [[ "${AGENTBOX_ONLY_PRINT_ALLOWLIST:-0}" == "1" ]]; then
  printf '%s\n' "${ALLOW_HOSTS[@]}"
  exit 0
fi

TOOLKITS_CSV="$(IFS=,; echo "${TOOLKITS[*]}")"
TOOLKIT_TAG="none"
if [[ ${#TOOLKITS[@]} -gt 0 && -n "${TOOLKITS_CSV}" ]]; then
  TOOLKIT_TAG="$(printf "%s," "${TOOLKITS[@]}" | tr '[:upper:]' '[:lower:]' | tr -cs 'a-z0-9,' '_' | sed 's/,$//')"
fi

TAG="agentbox/${TARGET_AGENT}:$(echo "${BASE_IMAGE}" | tr '/:' '_')_${TOOLKIT_TAG}"

if [[ "${VERBOSE}" == "1" ]]; then
  echo "-> Building image ${TAG} (base: ${BASE_IMAGE}, toolkits: ${TOOLKITS_CSV:-none})" >&2
  docker build \
    --file "${REPO_ROOT}/docker/Dockerfile" \
    --build-arg "BASE_IMAGE=${BASE_IMAGE}" \
    --build-arg "TOOLKITS=${TOOLKITS_CSV}" \
    --tag "${TAG}" \
    "${REPO_ROOT}"
else
  docker build \
    --quiet \
    --file "${REPO_ROOT}/docker/Dockerfile" \
    --build-arg "BASE_IMAGE=${BASE_IMAGE}" \
    --build-arg "TOOLKITS=${TOOLKITS_CSV}" \
    --tag "${TAG}" \
    "${REPO_ROOT}" >/dev/null
fi

if [[ "${BUILD_ONLY}" -eq 1 ]]; then
  echo "Build complete for ${TARGET_AGENT}"
  exit 0
fi

[[ "${VERBOSE}" == "1" ]] && echo "-> Launching sandbox for ${TARGET_AGENT}" >&2
MOUNTS=("-v" "${PWD}":/workspace)
if [[ -d "${CONFIG_PROJECT_DIR}" ]]; then
  MOUNTS+=("-v" "${CONFIG_PROJECT_DIR}:/workspace/.agentbox:ro")
fi
if [[ "${TARGET_AGENT}" == "codex" && -d "${HOST_CODEX_AUTH}" ]]; then
  MOUNTS+=("-v" "${HOST_CODEX_AUTH}:/home/agent/.codex")
fi
if [[ "${TARGET_AGENT}" == "claude" && -d "${HOST_CLAUDE_AUTH}" ]]; then
  MOUNTS+=("-v" "${HOST_CLAUDE_AUTH}:/home/agent/.claude")
fi

NETWORK_ARGS=()
FIREWALL_CID=""
ALLOW_HOSTS_ENV="${ALLOW_HOSTS[*]}"
ALLOWLIST_DESC="${ALLOW_HOSTS_ENV}"
[[ -z "${ALLOWLIST_DESC}" ]] && ALLOWLIST_DESC="none"

cleanup() {
  if [[ -n "${FIREWALL_CID}" ]]; then
    docker rm -f "${FIREWALL_CID}" >/dev/null 2>&1 || true
  fi
}
trap cleanup EXIT

if [[ "${FULL_NETWORK}" -eq 1 ]]; then
  NETWORK_ARGS=(--network bridge)
else
  FIREWALL_NAME="agentbox-firewall-${TARGET_AGENT}-$$"
  [[ "${VERBOSE}" == "1" ]] && echo "-> Starting firewall container (${ALLOWLIST_DESC})" >&2
  FIREWALL_CID="$(docker run \
    --rm \
    -d \
    --name "${FIREWALL_NAME}" \
    --network bridge \
    --cap-drop ALL \
    --cap-add NET_ADMIN \
    --security-opt no-new-privileges \
    --user root \
    --entrypoint /usr/local/bin/agent-firewall \
    -e "ALLOW_HOSTS=${ALLOW_HOSTS_ENV}" \
    -e "VERBOSE=${VERBOSE}" \
    "${TAG}")"
  NETWORK_ARGS=(--network "container:${FIREWALL_CID}")
fi

docker run \
  --rm \
  -i \
  ${TTY_OPT:+${TTY_OPT}} \
  --name "agentbox-${TARGET_AGENT}-$$" \
  "${NETWORK_ARGS[@]}" \
  --cap-drop ALL \
  --pids-limit 512 \
  --security-opt no-new-privileges \
  --workdir /workspace \
  "${MOUNTS[@]}" \
  "${TAG}" \
  "${RUN_CMD[@]}"
